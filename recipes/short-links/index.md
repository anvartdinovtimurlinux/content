---
title: "Короткие ссылки на NJS"
description: "Сделаем свой сервис коротких ссылок"
authors:
  - igsekor
tags:
  - doka
---

## Задача

Рано или поздно практически перед каждым разработчиком вставала задача использования сервиса коротких ссылок. Чаще всего такой сервис используется для публикации в социальных сетях или сбора специальной статистики в маркетинговых целях. Для разработчика есть два пути — использовать готовый сервис или написать свой. Я выбираю второй вариант! Использовать буду nginx.

Задача, которая стоит передо мной, — генерация короткого варианта ссылки на главную страницу с набором GET-параметров, которая лежит на моём же домене. Пример:

- Длинная ссылка: `https://mysite.dev/?source=twitter&site=doka&p=docker`.
- Короткая ссылка: `https://mysite.dev/get/72cbb2d3`

## Готовое решение

Установить модуль NJS для nginx согласно [официальной документации](https://nginx.org/ru/docs/njs/install.html).  Подробнее о модуле можно почитать в [официальной документации](https://nginx.org/en/docs/njs/) или в статье «[Ма­гия вне Хо­гварт­са: NJS](https://web-standards.ru/articles/magic-njs/)».

Включить модуль NJS и подключить нужный скрипт, добавив соответствующие строки в основной файл конфигурации:

```nginxconf
load_module modules/ngx_http_js_module.so;

http {
  js_import scripts/short_link.js;
}
```

Добавить строчки в конфигурацию для вашего сайта nginx:

```nginxconf
server {
  location / {
    error_page 404 /404/index.html;
    try_files $uri $uri/ /index.html =404;
  }

  location /add {
    js_content short_link.add;
  }

  location /get {
    js_content short_link.get;
  }
}
```

Добавить в поддиректорию _scripts_ в директории _nginx_ следующий скрипт:

```javascript
const fs = require('fs')

function getPage(link) {
  return new fetch(link)
    .then(reply => reply.text())
    .then(body => {
      resolve(body)
    })
    .catch(e => r.return(501, e.message))
}

function getLink(r) {
  const arguments = [];
  for (const key in r.args) {
    arguments.push(`${key}=${r.args[key]}`)
  }
  return `https://mysite.dev/?${arguments.join('&')}`
}

async function add(r) {
  const link = getLink(r)
  const hash = await crypto.subtle.digest('SHA-512', JSON.stringify(r.args))
  const shortHash = Buffer.from(hash).toString('hex').slice(0, 8)
  const path = `/links/${shortHash}.json`
  r.headersOut['Content-Type'] = "application/json charset=utf-8"
  try {
    fs.accessSync(path, fs.constants.R_OK | fs.constants.W_OK)
    r.return(200, `{ "status": "Already exists", "hash": "${shortHash}" }`)
  } catch (e) {
    const json = `{ "url": "${link}" }`
    fs.writeFileSync(`${path}`, json)
    r.return(201, `{ "status": "Created", "hash": "${shortHash}" }`)
  }
}

async function get(r) {
  const filePath = `/links/${r.uri.replace('/get/', '')}.json`
  const file = fs.readFileSync(filePath, { encoding: 'utf8' })
  const json = JSON.parse(file)
  r.return(301, json.url)
}

export default {
  add, get
}
```

Все файлы со ссылками будут лежать в папке _/links_, не забудьте выставить правильные права на папку.

## Разбор решения

### Конструирование ссылок

Какая задача сразу встаёт перед разработчиком при создании сервиса коротких ссылок? Нужно выбрать способ создания коротких ссылок. Можно использовать заранее заготовленные короткие ссылки. Например, для своей статьи на Доке можно сделать ссылку `https://mysite.dev/docker`. Такой подход позволяет сделать ссылки понятными человеку, что очень удобно для использования. Однако перечень «разумных» названий будет быстро исчерпан, необходимо заранее продумать о масштабировании. Зато такой подход легко реализовать на уровне сервера обычным перенаправлением. Для nginx перенаправление можно прописать прямо в секции `server` файла конфигурации:

```nginxconf
...
server {
  rewrite ^/docker https://doka.guide/tools/docker/ permanent;
}
```

Второй подход — генерировать ссылки автоматически при создании. В этом случае необходимо определиться с количеством ссылок, на которое вы можете рассчитывать. Здесь используется формула из комбинаторики для выборки с возвращением:

- выбираете количество необходимых вам комбинаций (например, 1000);
- выбираете набор символов, которые вы будете использовать, исходя из кодировки или иных соображений (например, цифры, то есть 10 символов);
- выбираете нужное количество разрядов, которые понадобятся для перекрытия диапазона, исходя из формулы: количество символов из набора возводим в степень количества разрядов (у нас получается 3).

Затем генерируете для каждой ссылки нужное количество символов из набора, озаботившись предварительно проверкой на уникальность. Проверку на уникальность можно заменить генерацией хеша по запрашиваемой ссылке.

### Подходы к реализации

Если вы являетесь единственным человеком, который генерирует ссылки, ссылок у вас немного, а генерировать эти ссылки нужно не часто, вполне может подойти способ с ручной настройкой сервера.

Если пользователей много, и/или вы хотите генерировать ссылки автоматически, код придётся написать. И сразу возникает вопрос, где хранить информацию о ссылках? Можно в оперативной памяти, можно в файлах, можно в базе данных. Первый вариант очень ненадёжен, его рассматривать не будем. Третий вариант требует настройки базы данных и написания кода для работы с ней, давайте его тоже опустим.

Ссылки можно хранить в одном файле в виде, например JSON-объекта или простых строчек в формате ключ значение. Ссылки можно хранить в отдельных директориях или файлах. Мой вариант — использовать отдельные файлы в формате JSON.

В отличие от варианта с базой данных, есть определённые ограничения на количество поддиректорий, которые могут быть созданы внутри директории (например, для ext4 максимальное количество — 65535). Также есть ограничение на максимальное количество файлов на диске (для ext4 максимальное количество ограничено ~ 4 миллиардами). Внимательно следите, чтобы не выйти за пределы диапазонов.
